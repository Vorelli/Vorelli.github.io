let e, t, n = !1; const l = "undefined" != typeof window ? window : {}, s = l.document || { head: {} }, o = { t: 0, l: "", jmp: e => e(), raf: e => requestAnimationFrame(e), ael: (e, t, n, l) => e.addEventListener(t, n, l), rel: (e, t, n, l) => e.removeEventListener(t, n, l), ce: (e, t) => new CustomEvent(e, t) }, i = e => Promise.resolve(e), c = (() => { try { return new CSSStyleSheet, "function" == typeof (new CSSStyleSheet).replaceSync } catch (e) { } return !1 })(), r = (e, t, n) => { n && n.map((([n, l, s]) => { const i = u(e, n), c = a(t, s), r = f(n); o.ael(i, l, c, r), (t.o = t.o || []).push((() => o.rel(i, l, c, r))) })) }, a = (e, t) => n => { try { 256 & e.t ? e.i[t](n) : (e.u = e.u || []).push([t, n]) } catch (e) { ee(e) } }, u = (e, t) => 8 & t ? l : e, f = e => 0 != (2 & e), d = "http://www.w3.org/1999/xlink", p = new WeakMap, h = e => "sc-" + e.p, y = {}, m = e => "object" == (e = typeof e) || "function" === e, $ = (e, t, ...n) => { let l = null, s = null, o = !1, i = !1; const c = [], r = t => { for (let n = 0; n < t.length; n++)l = t[n], Array.isArray(l) ? r(l) : null != l && "boolean" != typeof l && ((o = "function" != typeof e && !m(l)) && (l += ""), o && i ? c[c.length - 1].h += l : c.push(o ? b(null, l) : l), i = o) }; if (r(n), t) { t.key && (s = t.key); { const e = t.className || t.class; e && (t.class = "object" != typeof e ? e : Object.keys(e).filter((t => e[t])).join(" ")) } } if ("function" == typeof e) return e(null === t ? {} : t, c, v); const a = b(e, null); return a.m = t, c.length > 0 && (a.$ = c), a.v = s, a }, b = (e, t) => ({ t: 0, g: e, h: t, k: null, $: null, m: null, v: null }), w = {}, v = { forEach: (e, t) => e.map(g).forEach(t), map: (e, t) => e.map(g).map(t).map(k) }, g = e => ({ vattrs: e.m, vchildren: e.$, vkey: e.v, vname: e.S, vtag: e.g, vtext: e.h }), k = e => { if ("function" == typeof e.vtag) { const t = Object.assign({}, e.vattrs); return e.vkey && (t.key = e.vkey), e.vname && (t.name = e.vname), $(e.vtag, t, ...e.vchildren || []) } const t = b(e.vtag, e.vtext); return t.m = e.vattrs, t.$ = e.vchildren, t.v = e.vkey, t.S = e.vname, t }, S = (e, t, n, s, i, c) => { if (n !== s) { let r = Z(e, t), a = t.toLowerCase(); if ("class" === t) { const t = e.classList, l = C(n), o = C(s); t.remove(...l.filter((e => e && !o.includes(e)))), t.add(...o.filter((e => e && !l.includes(e)))) } else if ("style" === t) { for (const t in n) s && null != s[t] || (t.includes("-") ? e.style.removeProperty(t) : e.style[t] = ""); for (const t in s) n && s[t] === n[t] || (t.includes("-") ? e.style.setProperty(t, s[t]) : e.style[t] = s[t]) } else if ("key" === t); else if ("ref" === t) s && s(e); else if (r || "o" !== t[0] || "n" !== t[1]) { const l = m(s); if ((r || l && null !== s) && !i) try { if (e.tagName.includes("-")) e[t] = s; else { const l = null == s ? "" : s; "list" === t ? r = !1 : null != n && e[t] == l || (e[t] = l) } } catch (e) { } let o = !1; a !== (a = a.replace(/^xlink\:?/, "")) && (t = a, o = !0), null == s || !1 === s ? !1 === s && "" !== e.getAttribute(t) || (o ? e.removeAttributeNS(d, t) : e.removeAttribute(t)) : (!r || 4 & c || i) && !l && (s = !0 === s ? "" : s, o ? e.setAttributeNS(d, t, s) : e.setAttribute(t, s)) } else t = "-" === t[2] ? t.slice(3) : Z(l, a) ? a.slice(2) : a[2] + t.slice(3), n && o.rel(e, t, n, !1), s && o.ael(e, t, s, !1) } }, j = /\s/, C = e => e ? e.split(j) : [], M = (e, t, n, l) => { const s = 11 === t.k.nodeType && t.k.host ? t.k.host : t.k, o = e && e.m || y, i = t.m || y; for (l in o) l in i || S(s, l, o[l], void 0, n, t.t); for (l in i) S(s, l, o[l], i[l], n, t.t) }, O = (t, n, l) => { const o = n.$[l]; let i, c, r = 0; if (null !== o.h) i = o.k = s.createTextNode(o.h); else if (i = o.k = s.createElement(o.g), M(null, o, !1), null != e && i["s-si"] !== e && i.classList.add(i["s-si"] = e), o.$) for (r = 0; r < o.$.length; ++r)c = O(t, o, r), c && i.appendChild(c); return i }, x = (e, n, l, s, o, i) => { let c, r = e; for (r.shadowRoot && r.tagName === t && (r = r.shadowRoot); o <= i; ++o)s[o] && (c = O(null, l, o), c && (s[o].k = c, r.insertBefore(c, n))) }, P = (e, t, n, l, s) => { for (; t <= n; ++t)(l = e[t]) && (s = l.k, U(l), s.remove()) }, E = (e, t) => e.g === t.g && e.v === t.v, L = (e, t) => { const n = t.k = e.k, l = e.$, s = t.$, o = t.h; null === o ? ("slot" === t.g || M(e, t, !1), null !== l && null !== s ? ((e, t, n, l) => { let s, o, i = 0, c = 0, r = 0, a = 0, u = t.length - 1, f = t[0], d = t[u], p = l.length - 1, h = l[0], y = l[p]; for (; i <= u && c <= p;)if (null == f) f = t[++i]; else if (null == d) d = t[--u]; else if (null == h) h = l[++c]; else if (null == y) y = l[--p]; else if (E(f, h)) L(f, h), f = t[++i], h = l[++c]; else if (E(d, y)) L(d, y), d = t[--u], y = l[--p]; else if (E(f, y)) L(f, y), e.insertBefore(f.k, d.k.nextSibling), f = t[++i], y = l[--p]; else if (E(d, h)) L(d, h), e.insertBefore(d.k, f.k), d = t[--u], h = l[++c]; else { for (r = -1, a = i; a <= u; ++a)if (t[a] && null !== t[a].v && t[a].v === h.v) { r = a; break } r >= 0 ? (o = t[r], o.g !== h.g ? s = O(t && t[c], n, r) : (L(o, h), t[r] = void 0, s = o.k), h = l[++c]) : (s = O(t && t[c], n, c), h = l[++c]), s && f.k.parentNode.insertBefore(s, f.k) } i > u ? x(e, null == l[p + 1] ? null : l[p + 1].k, n, l, c, p) : c > p && P(t, i, u) })(n, l, t, s) : null !== s ? (null !== e.h && (n.textContent = ""), x(n, null, t, s, 0, s.length - 1)) : null !== l && P(l, 0, l.length - 1)) : e.h !== o && (n.data = o) }, U = e => { e.m && e.m.ref && e.m.ref(null), e.$ && e.$.map(U) }, W = e => Q(e).j, N = (e, t, n) => { const l = W(e); return { emit: e => T(l, t, { bubbles: !!(4 & n), composed: !!(2 & n), cancelable: !!(1 & n), detail: e }) } }, T = (e, t, n) => { const l = o.ce(t, n); return e.dispatchEvent(l), l }, A = (e, t) => { t && !e.C && t["s-p"] && t["s-p"].push(new Promise((t => e.C = t))) }, D = (e, t) => { if (e.t |= 16, !(4 & e.t)) return A(e, e.M), ue((() => F(e, t))); e.t |= 512 }, F = (e, t) => { const n = e.i; let l; return t ? (e.t |= 256, e.u && (e.u.map((([e, t]) => _(n, e, t))), e.u = null), l = _(n, "componentWillLoad")) : l = _(n, "componentWillUpdate"), z(l, (() => H(e, n, t))) }, H = async (e, t, n) => { const l = e.j, o = l["s-rc"]; n && (e => { const t = e.O, n = e.j, l = t.t, o = ((e, t) => { let n = h(t); const l = le.get(n); if (e = 11 === e.nodeType ? e : s, l) if ("string" == typeof l) { let t, o = p.get(e = e.head || e); o || p.set(e, o = new Set), o.has(n) || (t = s.createElement("style"), t.innerHTML = l, e.insertBefore(t, e.querySelector("link")), o && o.add(n)) } else e.adoptedStyleSheets.includes(l) || (e.adoptedStyleSheets = [...e.adoptedStyleSheets, l]); return n })(n.shadowRoot ? n.shadowRoot : n.getRootNode(), t); 10 & l && (n["s-sc"] = o, n.classList.add(o + "-h")) })(e); R(e, t), o && (o.map((e => e())), l["s-rc"] = void 0); { const t = l["s-p"], n = () => q(e); 0 === t.length ? n() : (Promise.all(t).then(n), e.t |= 4, t.length = 0) } }, R = (n, l) => { try { l = l.render(), n.t &= -17, n.t |= 2, ((n, l) => { const s = n.j, o = n.O, i = n.P || b(null, null), c = (e => e && e.g === w)(l) ? l : $(null, null, l); t = s.tagName, o.L && (c.m = c.m || {}, o.L.map((([e, t]) => c.m[t] = s[e]))), c.g = null, c.t |= 4, n.P = c, c.k = i.k = s.shadowRoot || s, e = s["s-sc"], L(i, c) })(n, l) } catch (e) { ee(e, n.j) } return null }, q = e => { const t = e.j, n = e.i, l = e.M; 64 & e.t ? _(n, "componentDidUpdate") : (e.t |= 64, B(t), _(n, "componentDidLoad"), e.U(t), l || V()), e.W(t), e.C && (e.C(), e.C = void 0), 512 & e.t && ae((() => D(e, !1))), e.t &= -517 }, V = () => { B(s.documentElement), ae((() => T(l, "appload", { detail: { namespace: "header-shared-webcomponents" } }))) }, _ = (e, t, n) => { if (e && e[t]) try { return e[t](n) } catch (e) { ee(e) } }, z = (e, t) => e && e.then ? e.then(t) : t(), B = e => e.classList.add("hydrated"), G = (e, t, n) => { if (t.N) { e.watchers && (t.T = e.watchers); const l = Object.entries(t.N), s = e.prototype; if (l.map((([e, [l]]) => { 31 & l || 2 & n && 32 & l ? Object.defineProperty(s, e, { get() { return ((e, t) => Q(this).A.get(t))(0, e) }, set(n) { ((e, t, n, l) => { const s = Q(e), o = s.j, i = s.A.get(t), c = s.t, r = s.i; if (n = ((e, t) => null == e || m(e) ? e : 4 & t ? "false" !== e && ("" === e || !!e) : 2 & t ? parseFloat(e) : 1 & t ? e + "" : e)(n, l.N[t][0]), (!(8 & c) || void 0 === i) && n !== i && (!Number.isNaN(i) || !Number.isNaN(n)) && (s.A.set(t, n), r)) { if (l.T && 128 & c) { const e = l.T[t]; e && e.map((e => { try { r[e](n, i, t) } catch (e) { ee(e, o) } })) } 2 == (18 & c) && D(s, !1) } })(this, e, n, t) }, configurable: !0, enumerable: !0 }) : 1 & n && 64 & l && Object.defineProperty(s, e, { value(...t) { const n = Q(this); return n.D.then((() => n.i[e](...t))) } }) })), 1 & n) { const n = new Map; s.attributeChangedCallback = function(e, t, l) { o.jmp((() => { const t = n.get(e); if (this.hasOwnProperty(t)) l = this[t], delete this[t]; else if (s.hasOwnProperty(t) && "number" == typeof this[t] && this[t] == l) return; this[t] = (null !== l || "boolean" != typeof this[t]) && l })) }, e.observedAttributes = l.filter((([e, t]) => 15 & t[0])).map((([e, l]) => { const s = l[1] || e; return n.set(s, e), 512 & l[0] && t.L.push([e, s]), s })) } } return e }, I = e => { _(e, "connectedCallback") }, J = (e, t = {}) => { const n = [], i = t.exclude || [], a = l.customElements, u = s.head, f = u.querySelector("meta[charset]"), d = s.createElement("style"), p = []; let y, m = !0; Object.assign(o, t), o.l = new URL(t.resourcesUrl || "./", s.baseURI).href, e.map((e => { e[1].map((t => { const l = { t: t[0], p: t[1], N: t[2], F: t[3] }; l.N = t[2], l.F = t[3], l.L = [], l.T = {}; const s = l.p, u = class extends HTMLElement { constructor(e) { super(e), Y(e = this, l), 1 & l.t && e.attachShadow({ mode: "open" }) } connectedCallback() { y && (clearTimeout(y), y = null), m ? p.push(this) : o.jmp((() => (e => { if (0 == (1 & o.t)) { const t = Q(e), n = t.O, l = () => { }; if (1 & t.t) r(e, t, n.F), I(t.i); else { t.t |= 1; { let n = e; for (; n = n.parentNode || n.host;)if (n["s-p"]) { A(t, t.M = n); break } } n.N && Object.entries(n.N).map((([t, [n]]) => { if (31 & n && e.hasOwnProperty(t)) { const n = e[t]; delete e[t], e[t] = n } })), (async (e, t, n, l, s) => { if (0 == (32 & t.t)) { { if (t.t |= 32, (s = ne(n)).then) { const e = () => { }; s = await s, e() } s.isProxied || (n.T = s.watchers, G(s, n, 2), s.isProxied = !0); const e = () => { }; t.t |= 8; try { new s(t) } catch (e) { ee(e) } t.t &= -9, t.t |= 128, e(), I(t.i) } if (s.style) { let e = s.style; const t = h(n); if (!le.has(t)) { const l = () => { }; ((e, t, n) => { let l = le.get(e); c && n ? (l = l || new CSSStyleSheet, "string" == typeof l ? l = t : l.replaceSync(t)) : l = t, le.set(e, l) })(t, e, !!(1 & n.t)), l() } } } const o = t.M, i = () => D(t, !0); o && o["s-rc"] ? o["s-rc"].push(i) : i() })(0, t, n) } l() } })(this))) } disconnectedCallback() { o.jmp((() => (() => { if (0 == (1 & o.t)) { const e = Q(this), t = e.i; e.o && (e.o.map((e => e())), e.o = void 0), _(t, "disconnectedCallback") } })())) } componentOnReady() { return Q(this).H } }; l.R = e[0], i.includes(s) || a.get(s) || (n.push(s), a.define(s, G(u, l, 1))) })) })), d.innerHTML = n + "{visibility:hidden}.hydrated{visibility:inherit}", d.setAttribute("data-styles", ""), u.insertBefore(d, f ? f.nextSibling : u.firstChild), m = !1, p.length ? p.map((e => e.connectedCallback())) : o.jmp((() => y = setTimeout(V, 30))) }, K = new WeakMap, Q = e => K.get(e), X = (e, t) => K.set(t.i = e, t), Y = (e, t) => { const n = { t: 0, j: e, O: t, A: new Map }; return n.D = new Promise((e => n.W = e)), n.H = new Promise((e => n.U = e)), e["s-p"] = [], e["s-rc"] = [], r(e, n, t.F), K.set(e, n) }, Z = (e, t) => t in e, ee = (e, t) => (0, console.error)(e, t), te = new Map, ne = e => {
  const t = e.p.replace(/-/g, "_"), n = e.R, l = te.get(n); return l ? l[t] : import(`./${n}.entry.js`).then((e => (te.set(n, e), e[t])), ee)
  /*!__STENCIL_STATIC_IMPORT_SWITCH__*/
}, le = new Map, se = [], oe = [], ie = (e, t) => l => { e.push(l), n || (n = !0, t && 4 & o.t ? ae(re) : o.raf(re)) }, ce = e => { for (let t = 0; t < e.length; t++)try { e[t](performance.now()) } catch (e) { ee(e) } e.length = 0 }, re = () => { ce(se), ce(oe), (n = se.length > 0) && o.raf(re) }, ae = e => i().then(e), ue = ie(oe, !0); export { w as H, J as b, N as c, W as g, $ as h, i as p, X as r }
